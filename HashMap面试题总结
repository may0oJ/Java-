1. HashMap的数据结构/说下HashMap
答：HashMap由基础的数组+链表构成，当链表过长时会转化为红黑树避免链条过长。数组是HashMap的主体用于存储拥有对应下标的entry，
链表则主要是解决hash collision而存在的，即entry下标相同的情况。

2.HashMap的工作原理
答：HashMap底层是由数组和链表构成，其中的每个元素以键值对的形式存在，其由Node内部类实现（实现的是Map.Entry<K,V>接口）。HashMap最常用
的也是其中包含核心内容最多的部分是其put & get 方法，分别实现存储和获取。
put方法的基本流程是，存储对象时：
1.将K/V键值传入put()方法；
2.首先检查数组是否初始化，若尚未初始化则初始化一个哈希数组（这里可能会调用resize方法）；
2.5如果Key为null，则调用PutForNullKey（value）方法，将其放到index为0的桶的位置，如果table[0]的链表已存在键为null的元素，则将新value赋值给它；没有则创建新Entry。
3.将Key的hashcode通过hash函数（扰动函数，1.7中4次位运算4次异或，1.8中hashcode前16位与后16位进行异或运算）得到其对应的hash值，然后通过indexFor
方法将hash值与当前数组的长度-1进行&运算，得到的即为其对应的存储的地址。
4.检查该下标的位置是否存在键，若已存在，则遍历链表检查是否有与该键相同的entry存在，若有则直接覆盖为新的value；若遍历链表发现没有相同的key的entry，则在链表尾部建立新的
entry（1.7采用头插法，但在多个线程同时插入一个entry的时候若同时发生了扩容，则有可能会导致出现环形链表；1.8改用尾插法从而避免了这种情况的发生）。
4.5在插入时同时还会检查当前是否为红黑树结构，若是则会采用树的插入方法。
5.在插入之后会检查当前链表上的元素数量是否达到了8，若达到则会将链表转换为红黑树。
6.之后会检查当前hashmap中的元素个数即size是否已经超过了loadfacotr*capacity(初始化时默认为0.75,16；也可以自定义传参数进去；自己设定的capacity会通过tableSizeFor()方法获得
在其之上最接近的2的整数次幂作为实际capacity，1除外)，若已超过会调用resize方法。
7.操作结束后最终返回被覆盖的value，或是null表示没有对应的Key存在，也有可能是之前的Key对应的键值为null。

get方法的基本流程是，获取对象时：
1.将Key传入hash函数，通过hash函数计算key的hash值，计算index，前往对应index的桶的位置；
2.顺序遍历链表或树，检查是否有相同的Key，若有返回该Key对应的value，没有返回null，也有可能对应的value就是null(因为HashMap允许存在多个null值).
